(window.webpackJsonp=window.webpackJsonp||[]).push([[20],{377:function(a,e,t){"use strict";t.r(e);var s=t(44),r=Object(s.a)({},(function(){var a=this,e=a.$createElement,t=a._self._c||e;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("h1",{attrs:{id:"webpack"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#webpack"}},[a._v("#")]),a._v(" webpack")]),a._v(" "),t("h2",{attrs:{id:"webpack-执行流程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#webpack-执行流程"}},[a._v("#")]),a._v(" webpack 执行流程")]),a._v(" "),t("p",[a._v("webpack 的构建流程。")]),a._v(" "),t("p",[a._v("首先解析 config 和 shell 中的配置项，合并生成 options")]),a._v(" "),t("p",[a._v("然后调用 webpack 函数，返回 compiler 对象，实例化 compiler 对象后会初始化 webpack 内置的插件和 options 配置，并将它们挂载在 compiler 对象上，compiler 相当于一个全局的执行上下文，上面记录了完整的 webpack 环境信息，一个 webpack 进程中，只会生成一次 compiler")]),a._v(" "),t("p",[t("strong",[a._v("执行 compiler 的 run 方法开始编译")]),a._v("，首先构建 compilation 对象，这个对象负责组织整个编译过程，对象上包含每个构建环节对应的方法，还保存着 modules，chunks，生成的 assets 以及最后生成 js 的 template，每次编译都会生成一个新的 compilation")]),a._v(" "),t("p",[t("strong",[a._v("在 make 钩子中执行 compilation 的 addEntry 方法")]),a._v("，addEntry 中又调用 _addModuleChain 开始构建模块")]),a._v(" "),t("p",[a._v("构建模块首先执行相应的 loader 对读取的源文件进行处理，然后转成 ast，遍历 ast 找到所有的依赖模块，接着递归构建所有的依赖模块。")]),a._v(" "),t("p",[t("strong",[a._v("执行 compilation 的 seal 方法")]),a._v("，这个方法主要调用各插件对构建后的结果进行封装和修改。")]),a._v(" "),t("p",[a._v("最后调用 "),t("strong",[a._v("compiler.emitAssets")]),a._v(" 按照 output 中的配置输出文件。")]),a._v(" "),t("h2",{attrs:{id:"常用的钩子"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#常用的钩子"}},[a._v("#")]),a._v(" 常用的钩子")]),a._v(" "),t("p",[t("strong",[a._v("compiler：")])]),a._v(" "),t("ul",[t("li",[a._v("run")]),a._v(" "),t("li",[a._v("compile")]),a._v(" "),t("li",[a._v("make")]),a._v(" "),t("li",[a._v("emit")]),a._v(" "),t("li",[a._v("done")])]),a._v(" "),t("p",[t("strong",[a._v("compilation：")])]),a._v(" "),t("ul",[t("li",[a._v("buildModule")]),a._v(" "),t("li",[a._v("seal")]),a._v(" "),t("li",[a._v("optimize")])]),a._v(" "),t("h2",{attrs:{id:"loader"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#loader"}},[a._v("#")]),a._v(" loader")]),a._v(" "),t("p",[a._v("就是一个函数，接受「源文件文件内容」做为参数")]),a._v(" "),t("h2",{attrs:{id:"plugin"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#plugin"}},[a._v("#")]),a._v(" plugin")]),a._v(" "),t("p",[a._v("一个类，需要实现 apply 方法，apply 方法接受「compiler」做为参数")]),a._v(" "),t("h2",{attrs:{id:"优化手段"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#优化手段"}},[a._v("#")]),a._v(" 优化手段")]),a._v(" "),t("h3",{attrs:{id:"module-优化配置"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#module-优化配置"}},[a._v("#")]),a._v(" module 优化配置")]),a._v(" "),t("ul",[t("li",[a._v("noParse：去除不需要 webpack 处理的文件")]),a._v(" "),t("li",[a._v("rules：test、include、exclude 配置范围内需要处理的文件")])]),a._v(" "),t("h3",{attrs:{id:"resolve-优化配置"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#resolve-优化配置"}},[a._v("#")]),a._v(" resolve 优化配置")]),a._v(" "),t("ul",[t("li",[a._v("alias：路径别名")]),a._v(" "),t("li",[a._v("extensions：导入文件后缀优先级")])]),a._v(" "),t("h3",{attrs:{id:"相关优化-loader-plugin"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#相关优化-loader-plugin"}},[a._v("#")]),a._v(" 相关优化 loader plugin")]),a._v(" "),t("ul",[t("li",[a._v("ThreadLoader：多进程处理 loader")]),a._v(" "),t("li",[a._v("MiniCssExtractPlugin：提取 css")]),a._v(" "),t("li",[a._v("OptimizeCssAssetsWebpackPlugin：压缩 css，optimization.minimizer")]),a._v(" "),t("li",[a._v("TerserWebpackPlugin：多进程压缩 js，optimization.minimizer")])]),a._v(" "),t("h3",{attrs:{id:"splitchunks-代码分割"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#splitchunks-代码分割"}},[a._v("#")]),a._v(" splitChunks 代码分割")]),a._v(" "),t("p",[a._v("主要是 optimization.splitChunks.cacheGroups 配置")]),a._v(" "),t("h2",{attrs:{id:"hmr-热更新原理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#hmr-热更新原理"}},[a._v("#")]),a._v(" HMR 热更新原理")]),a._v(" "),t("p",[a._v("服务端和客户端会建立 websocket 连接，当 webpack 监听到文件被修改，触发了重新编译，编译完成后在 done 钩子中通过 websocket 向客户端推动当前编译的 hash，如果客户端比较 hash 不一致，就会通过 ajax 和 jsonp 向服务端获取最新的资源完成替换。")]),a._v(" "),t("p",[a._v("所以一般来说 webpack-dev-server 和 HMR 要配对使用，否则会无效，如果使用了 webpack-dev-middleware 而没有使用 webpack-dev-server，请使用 webpack-hot-middleware 依赖包开启 HMR。")]),a._v(" "),t("h2",{attrs:{id:"tree-shaking-原理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#tree-shaking-原理"}},[a._v("#")]),a._v(" tree shaking 原理")]),a._v(" "),t("p",[a._v("tree shaking 是 webpack 的一项功能，tree shaking 只能在 ESModule 中使用，如果先通过 babel 转为 CommonJS 就用不了。")]),a._v(" "),t("p",[a._v("ES6 模块依赖关系是确定的，和运行时的状态无关，可以进行可靠的静态分析，在编译阶段分析出引入但是没用的模块，不打包到 boundle 里。")]),a._v(" "),t("p",[a._v("要使用这项技术，只能使用 webpack 的模块处理，加上 babel 的 es6 转换能力（需要关闭模块转换）。")])])}),[],!1,null,null,null);e.default=r.exports}}]);