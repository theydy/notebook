(window.webpackJsonp=window.webpackJsonp||[]).push([[18],{375:function(t,s,e){"use strict";e.r(s);var a=e(44),r=Object(a.a)({},(function(){var t=this,s=t.$createElement,e=t._self._c||s;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"性能优化"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#性能优化"}},[t._v("#")]),t._v(" 性能优化")]),t._v(" "),e("h2",{attrs:{id:"cdn-加速"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#cdn-加速"}},[t._v("#")]),t._v(" CDN 加速")]),t._v(" "),e("p",[t._v("利用最靠近每位用户的服务器，更快、更可靠地将音乐、图片、视频、应用程序及其他文件发送给用户")]),t._v(" "),e("h2",{attrs:{id:"图片懒加载"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#图片懒加载"}},[t._v("#")]),t._v(" 图片懒加载")]),t._v(" "),e("h3",{attrs:{id:"js-计算-image-标签是否出现在可视区域"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#js-计算-image-标签是否出现在可视区域"}},[t._v("#")]),t._v(" js 计算 image 标签是否出现在可视区域")]),t._v(" "),e("ul",[e("li",[t._v("window.innerHeight 是浏览器可视区的高度")]),t._v(" "),e("li",[t._v("document.body.scrollTop || document.documentElement.scrollTop 是浏览器滚动的过的距离")]),t._v(" "),e("li",[t._v("img.offsetTop 是元素顶部距离文档顶部的高度（包括滚动条的距离）")]),t._v(" "),e("li",[t._v("图片加载条件：img.offsetTop < window.innerHeight + document.body.scrollTop")])]),t._v(" "),e("h3",{attrs:{id:"intersectionobserver"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#intersectionobserver"}},[t._v("#")]),t._v(" IntersectionObserver")]),t._v(" "),e("p",[t._v("IntersectionObserver 接口 (从属于Intersection Observer API) 提供了一种异步观察目标元素与其祖先元素或顶级文档视窗(viewport)交叉状态的方法。祖先元素与视窗(viewport)被称为根(root)。")]),t._v(" "),e("h2",{attrs:{id:"合理使用缓存"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#合理使用缓存"}},[t._v("#")]),t._v(" 合理使用缓存")]),t._v(" "),e("p",[t._v("js 文件、css 文件等静态资源使用"),e("strong",[t._v("强缓存")]),t._v("，这些静态资源修改后一帮都会改文件名，比如 js、css 重新打包后会带 hash")]),t._v(" "),e("p",[t._v("入口文件 index 等名字不会变但内容常变的文件使用"),e("strong",[t._v("协商缓存")])]),t._v(" "),e("h2",{attrs:{id:"节流防抖"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#节流防抖"}},[t._v("#")]),t._v(" 节流防抖")]),t._v(" "),e("ul",[e("li",[t._v("函数防抖：是指在事件被触发 n 秒后再执行回调，如果在这 n 秒内事件又被触发，则重新计时。这可以使用在一些点击请求的事件上，避免因为用户的多次点击向后端发送多次请求。")]),t._v(" "),e("li",[t._v("函数节流：是指规定一个单位时间，在这个单位时间内，只能有一次触发事件的回调函数执行，如果在同一个单位时间内某事件被触发多次，只有一次能生效。节流可以使用在 scroll 函数的事件监听上，通过事件节流来降低事件调用的频率。")])]),t._v(" "),e("p",[t._v("防抖函数的应用场景：")]),t._v(" "),e("ul",[e("li",[t._v("按钮提交场景：防⽌多次提交按钮，只执⾏最后提交的⼀次")])]),t._v(" "),e("p",[t._v("节流函数的适⽤场景：")]),t._v(" "),e("ul",[e("li",[t._v("拖拽场景：固定时间内只执⾏⼀次，防⽌超⾼频次触发位置变动")]),t._v(" "),e("li",[t._v("缩放场景：监控浏览器 resize")]),t._v(" "),e("li",[t._v("动画场景：避免短时间内多次触发动画引起性能问题")])]),t._v(" "),e("h2",{attrs:{id:"图片优化"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#图片优化"}},[t._v("#")]),t._v(" 图片优化")]),t._v(" "),e("ul",[e("li",[t._v("css 代替图片")]),t._v(" "),e("li",[t._v("小图使用 base64")]),t._v(" "),e("li",[t._v("图片格式：JPG 适合用于大图，如背景之类的、PNG 适合用于精度要求高或透明要求的图、WebP 新格式能用最好")])]),t._v(" "),e("h2",{attrs:{id:"webpack-优化"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#webpack-优化"}},[t._v("#")]),t._v(" WebPack 优化")]),t._v(" "),e("h3",{attrs:{id:"减少打包体积"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#减少打包体积"}},[t._v("#")]),t._v(" 减少打包体积")]),t._v(" "),e("ul",[e("li",[t._v("压缩代码：以利⽤ webpack 的 UglifyJsPlugin 来压缩 JS ⽂件， 利⽤ cssnano （css-loader?minimize）来压缩css")]),t._v(" "),e("li",[t._v("按需加载：如将每个路由页面单独打包为一个文件")]),t._v(" "),e("li",[t._v("Tree Shaking：删除未使用的代码")]),t._v(" "),e("li",[t._v("提取公共第三方库：SplitChunksPlugin")])])])}),[],!1,null,null,null);s.default=r.exports}}]);