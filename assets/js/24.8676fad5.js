(window.webpackJsonp=window.webpackJsonp||[]).push([[24],{382:function(t,e,v){"use strict";v.r(e);var a=v(44),_=Object(a.a)({},(function(){var t=this,e=t.$createElement,v=t._self._c||e;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("h1",{attrs:{id:"微前端"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#微前端"}},[t._v("#")]),t._v(" 微前端")]),t._v(" "),v("p",[v("a",{attrs:{href:"https://juejin.cn/post/7100844652995018783#heading-12",target:"_blank",rel:"noopener noreferrer"}},[t._v("入门微前端，从single-spa到qiankun"),v("OutboundLink")],1)]),t._v(" "),v("p",[v("a",{attrs:{href:"https://juejin.cn/post/6844904048043229192#heading-10",target:"_blank",rel:"noopener noreferrer"}},[t._v("从0实现一个single-spa的前端微服务"),v("OutboundLink")],1)]),t._v(" "),v("p",[t._v("一个微前端需要实现如下功能：")]),t._v(" "),v("ul",[v("li",[t._v("进行路由劫持")]),t._v(" "),v("li",[t._v("渲染子应用")]),t._v(" "),v("li",[t._v("实现 JS 沙箱及样式隔离")]),t._v(" "),v("li",[t._v("提升体验性的功能")])]),t._v(" "),v("h2",{attrs:{id:"微前端优势"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#微前端优势"}},[t._v("#")]),t._v(" 微前端优势")]),t._v(" "),v("ul",[v("li",[t._v("无技术栈限制：主框架不限制接入应用的技术栈，子应用具备完全自主权")]),t._v(" "),v("li",[t._v("独立开发，独立部署，子应用的仓库独立，前后端可独立进行开发，部署完成后主框架自动完成同步更新")]),t._v(" "),v("li",[t._v("独立运行时，每个子应用之间状态隔离，运行时状态不共享")])]),t._v(" "),v("h2",{attrs:{id:"实现微前端的几种方案"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#实现微前端的几种方案"}},[t._v("#")]),t._v(" 实现微前端的几种方案")]),t._v(" "),v("table",[v("thead",[v("tr",[v("th",{staticStyle:{"text-align":"center"}},[t._v("方案")]),t._v(" "),v("th",{staticStyle:{"text-align":"center"}},[t._v("描述")]),t._v(" "),v("th",{staticStyle:{"text-align":"center"}},[t._v("优点")]),t._v(" "),v("th",{staticStyle:{"text-align":"center"}},[t._v("缺点")])])]),t._v(" "),v("tbody",[v("tr",[v("td",{staticStyle:{"text-align":"center"}},[t._v("Nginx 路由转发")]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[t._v("通过 Nginx 配置反向代理来实现不同路径映射到不同应用")]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[t._v("简单，快速，易配置")]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[t._v("在切换应用时会触发浏览器刷新，影响体验")])]),t._v(" "),v("tr",[v("td",{staticStyle:{"text-align":"center"}},[t._v("iframe 嵌套")]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[t._v("父应用单独是一个页面，每个子应用嵌套一个 iframe")]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[t._v("实现简单，子应用之间自带沙箱，天然隔离，互不影响")]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[t._v("隔离性无法被突破，导致应用间上下文无法被共享；太过简单而显得 low")])]),t._v(" "),v("tr",[v("td",{staticStyle:{"text-align":"center"}},[t._v("npm包形式")]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[t._v("子工程以 NPM 包的形式发布源码；打包构建发布还是由基座工程管理，打包时集成。")]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[t._v("打包部署慢，不能单独部署")]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[t._v("打包部署慢，不能单独部署")])]),t._v(" "),v("tr",[v("td",{staticStyle:{"text-align":"center"}},[t._v("通用中心路由基座式")]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[t._v("子工程可以使用不同技术栈；子工程之间完全独立，无任何依赖；统一由基座工程进行管理，按照 DOM 节点的注册、挂载、卸载来完成。")]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[t._v("不限定技术栈，单独部署")]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[t._v("通信方式不够灵活")])]),t._v(" "),v("tr",[v("td",{staticStyle:{"text-align":"center"}},[t._v("特定中心路由基座式")]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[t._v("子业务线之间使用相同技术栈；基座工程和子工程可以单独开发单独部署；子工程有能力复用基座工程的公共基建。")]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[t._v("通信方式多，单独部署")]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[t._v("限定技术栈")])])])]),t._v(" "),v("h2",{attrs:{id:"目前主流的微前端框架"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#目前主流的微前端框架"}},[t._v("#")]),t._v(" 目前主流的微前端框架")]),t._v(" "),v("ul",[v("li",[t._v("Single-SPA：是一个用于前端微服务化的 JavaScript 前端解决方案 (本身没有处理样式隔离， js 执行隔离) 实现了路由劫持和应用加载")]),t._v(" "),v("li",[t._v("qiankun：基于 Single-SPA, 提供了更加开箱即用的 API（single-spa+sandbox+import-html-entry）做到了，技术栈无关，并且接入简单")])]),t._v(" "),v("p",[t._v("总结：子应用可以独立部署，运行时动态加载主子应用完全解耦，技术栈无关，靠的是协议接入（子应用必须导出 bootstrap，mount，unmount 方法）")]),t._v(" "),v("h2",{attrs:{id:"single-spa"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#single-spa"}},[t._v("#")]),t._v(" Single-SPA")]),t._v(" "),v("p",[t._v("single-spa 的原理就是，将子项目中的 "),v("code",[t._v("link/script")]),t._v(" 标签和 "),v("code",[t._v('<div id="app"></div>')]),t._v(" 插入到主项目，而这个操作的核心就是动态加载 "),v("code",[t._v("js")]),t._v(" 和 "),v("code",[t._v("css")]),t._v("。")]),t._v(" "),v("p",[t._v("动态加载 "),v("code",[t._v("js")]),t._v(" 使用的是 "),v("code",[t._v("system.js")]),t._v("，借助这个插件，只需要将子项目的 "),v("code",[t._v("app.js")]),t._v(" 暴露给它即可。")]),t._v(" "),v("p",[t._v("system.js 的作用就是动态按需加载模块。假如我们子项目都使用了 vue、vuex、vue-router，每个项目都打包一次，就会很浪费。system.js 可以配合 webpack 的 externals 属性，将这些模块配置成外链，然后实现按需加载")]),t._v(" "),v("h3",{attrs:{id:"css-污染的问题"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#css-污染的问题"}},[t._v("#")]),t._v(" css 污染的问题")]),t._v(" "),v("p",[t._v("首先 "),v("code",[t._v("css-scoped")]),t._v(" 解决 95% 的样式污染，然后就是全局样式可能会造成污染，我们只需要将全局样式用一个 "),v("code",[t._v("id/class")]),t._v(" 包裹着就可以了，这样这些全局样式仅在这个 "),v("code",[t._v("id/class")]),t._v(" 范围内生效。")]),t._v(" "),v("p",[t._v("在子系统加载时(mount) 给 "),v("code",[t._v("<body>")]),t._v(" 加一个特殊的 "),v("code",[t._v("id/class")]),t._v("，然后在子系统卸载时(unmount) 删掉这个 "),v("code",[t._v("id/class")]),t._v("。而子系统的全局样式都仅在这个 "),v("code",[t._v("id/class")]),t._v(" 范围内生效，如果子系统独立运行，只需要在子系统的入口文件 "),v("code",[t._v("index.html")]),t._v(" 里面给 "),v("code",[t._v("<body>")]),t._v(" 手动加上这个 "),v("code",[t._v("id/class")]),t._v(" 即可。")]),t._v(" "),v("h3",{attrs:{id:"js-污染的问题"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#js-污染的问题"}},[t._v("#")]),t._v(" js 污染的问题")]),t._v(" "),v("p",[t._v("暂时没有很好的办法解决，但是可以靠编码规范来约束：页面销毁之前清除自己页面上的定时器/全局事件，必要的时候，全局变量也应该销毁。")]),t._v(" "),v("h3",{attrs:{id:"系统之间如何通信"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#系统之间如何通信"}},[t._v("#")]),t._v(" 系统之间如何通信")]),t._v(" "),v("p",[t._v("系统之间通信一般有两种方式：自定义事件和本地存储。如果是两个系统相互跳转，可以用 URL 传数据。")]),t._v(" "),v("p",[t._v("通用数据还可以挂在在 window 上，如果挂在在 window 上有个问题是如何防止在控制台打开的情况下防止重要数据暴露，有两种方法：")]),t._v(" "),v("ul",[v("li",[t._v("监控 window 的 innerHeight outerHeight 差值，如果过大说明此时可能打开控制台")]),t._v(" "),v("li",[t._v("重写对象的 toString 方法，然后使用 "),v("code",[t._v("console.log('%s', obj)")]),t._v(" 调用，console 函数语句只有在控制台打开时才会执行，此时由于类型转换的关系会调用 obj 的 toString 方法，可以该方法里改变全局变量，知道是否打开控制台。")])]),t._v(" "),v("h3",{attrs:{id:"子系统如何实现keep-alive"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#子系统如何实现keep-alive"}},[t._v("#")]),t._v(" 子系统如何实现keep-alive")]),t._v(" "),v("p",[t._v("查看 single-spa-vue 源码可以发现，在 unmount 生命周期，它将 vue 实例 destroy（销毁了）并且清空了 DOM。所以实现 keep-alive 的关键在于子系统的 unmount 周期中不销毁 vue 实例并且不清空 DOM，采用 display:none 来隐藏子系统。而在 mount 周期，先判断子系统是否存在，如果存在，则去掉其 display:none 即可。")]),t._v(" "),v("h2",{attrs:{id:"qiankun-框架"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#qiankun-框架"}},[t._v("#")]),t._v(" qiankun 框架")]),t._v(" "),v("p",[t._v("qiankun 是蚂蚁金服开源的基于 single-spa 的一个前端微服务框架")]),t._v(" "),v("h3",{attrs:{id:"js沙箱-sandbox-是如何实现的"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#js沙箱-sandbox-是如何实现的"}},[t._v("#")]),t._v(" js沙箱（sandbox）是如何实现的")]),t._v(" "),v("p",[t._v("我们知道所有的全局的方法（alert，setTimeout，isNaN 等）、全局的变/常量（NaN，Infinity，var 声明的全局变量等）和全局对象（Array，String，Date 等）都属于 window 对象，而能导致 js 污染的也就是这些全局的方法和对象。")]),t._v(" "),v("p",[t._v("所以 qiankun 解决 js 污染的办法是：在子系统加载之前对 window 对象做一个快照（拷贝），然后在子系统卸载的时候恢复这个快照，即可以保证每次子系统运行的时候都是一个全新的 window 对象环境。")]),t._v(" "),v("p",[t._v("那么如何监测 window 对象的变化呢，直接将 window 对象进行一下深拷贝，然后深度对比各个属性显然可行性不高，qiankun 框架采用的是 ES6 新特性，proxy 代理方法。大致原理就是记录 window 对象在子系统运行期间新增、修改和删除的属性和方法，然后会在子系统卸载的时候复原这些操作。")]),t._v(" "),v("p",[t._v("重写事件绑定/解绑和定时器相关函数。addEventListener、removeEventListener、setInterval。不清除 setTimeout，毕竟使用了一次之后就没用了，影响不大")]),t._v(" "),v("h3",{attrs:{id:"如何消除全局函数的影响"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#如何消除全局函数的影响"}},[t._v("#")]),t._v(" 如何消除全局函数的影响")]),t._v(" "),v("p",[t._v("function 关键字直接声明一个全局函数，这个函数属于 window 对象，但是无法被 delete")]),t._v(" "),v("p",[t._v("声明全局函数有两种办法，一种是 function 关键字在全局环境下声明，另一种是以变量的形式添加：window.a = () => {}。我们知道 function 声明的全局函数是无法删除的，而变量的形式是可以删除的，qiankun 直接避免了function 关键字声明的全局函数。")]),t._v(" "),v("h3",{attrs:{id:"css-污染的问题-2"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#css-污染的问题-2"}},[t._v("#")]),t._v(" css 污染的问题")]),t._v(" "),v("p",[t._v("在子系统卸载的时候，将子系统引入css使用的 "),v("code",[t._v("<link>")]),t._v("、"),v("code",[t._v("<style>")]),t._v(" 标签移除掉。移除的办法是重写 "),v("code",[t._v("<head>")]),t._v(" 标签的 appendChild 方法，办法类似定时器的重写。")]),t._v(" "),v("p",[t._v("子系统加载时，会将所需要的 js/css 文件插入到 "),v("code",[t._v("<head>")]),t._v(" 标签，而重写的 appendChild 方法会记录所插入的标签，然后子系统卸载的时候，会移除这些标签。")])])}),[],!1,null,null,null);e.default=_.exports}}]);