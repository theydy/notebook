# 微前端

[入门微前端，从single-spa到qiankun](https://juejin.cn/post/7100844652995018783#heading-12)

[从0实现一个single-spa的前端微服务](https://juejin.cn/post/6844904048043229192#heading-10)

一个微前端需要实现如下功能：

- 进行路由劫持
- 渲染子应用
- 实现 JS 沙箱及样式隔离
- 提升体验性的功能

## 微前端优势

- 无技术栈限制：主框架不限制接入应用的技术栈，子应用具备完全自主权
- 独立开发，独立部署，子应用的仓库独立，前后端可独立进行开发，部署完成后主框架自动完成同步更新
- 独立运行时，每个子应用之间状态隔离，运行时状态不共享

## 实现微前端的几种方案

| 方案 | 描述 | 优点 | 缺点 |
| :--: | :--: | :--: | :--: |
| Nginx 路由转发 | 通过 Nginx 配置反向代理来实现不同路径映射到不同应用 | 简单，快速，易配置 | 在切换应用时会触发浏览器刷新，影响体验 |
| iframe 嵌套 | 父应用单独是一个页面，每个子应用嵌套一个 iframe | 实现简单，子应用之间自带沙箱，天然隔离，互不影响 | 隔离性无法被突破，导致应用间上下文无法被共享；太过简单而显得 low |
| npm包形式 | 子工程以 NPM 包的形式发布源码；打包构建发布还是由基座工程管理，打包时集成。 | 打包部署慢，不能单独部署 | 打包部署慢，不能单独部署 |
| 通用中心路由基座式 | 子工程可以使用不同技术栈；子工程之间完全独立，无任何依赖；统一由基座工程进行管理，按照 DOM 节点的注册、挂载、卸载来完成。 | 不限定技术栈，单独部署 | 通信方式不够灵活 |
| 特定中心路由基座式 | 子业务线之间使用相同技术栈；基座工程和子工程可以单独开发单独部署；子工程有能力复用基座工程的公共基建。 | 通信方式多，单独部署 | 限定技术栈 |

## 目前主流的微前端框架

- Single-SPA：是一个用于前端微服务化的 JavaScript 前端解决方案 (本身没有处理样式隔离， js 执行隔离) 实现了路由劫持和应用加载
- qiankun：基于 Single-SPA, 提供了更加开箱即用的 API（single-spa+sandbox+import-html-entry）做到了，技术栈无关，并且接入简单

总结：子应用可以独立部署，运行时动态加载主子应用完全解耦，技术栈无关，靠的是协议接入（子应用必须导出 bootstrap，mount，unmount 方法）

## Single-SPA

single-spa 的原理就是，将子项目中的 `link/script` 标签和 `<div id="app"></div>` 插入到主项目，而这个操作的核心就是动态加载 `js` 和 `css`。

动态加载 `js` 使用的是 `system.js`，借助这个插件，只需要将子项目的 `app.js` 暴露给它即可。

system.js 的作用就是动态按需加载模块。假如我们子项目都使用了 vue、vuex、vue-router，每个项目都打包一次，就会很浪费。system.js 可以配合 webpack 的 externals 属性，将这些模块配置成外链，然后实现按需加载

### css 污染的问题

首先 `css-scoped` 解决 95% 的样式污染，然后就是全局样式可能会造成污染，我们只需要将全局样式用一个 `id/class` 包裹着就可以了，这样这些全局样式仅在这个 `id/class` 范围内生效。

在子系统加载时(mount) 给 `<body>` 加一个特殊的 `id/class`，然后在子系统卸载时(unmount) 删掉这个 `id/class`。而子系统的全局样式都仅在这个 `id/class` 范围内生效，如果子系统独立运行，只需要在子系统的入口文件 `index.html` 里面给 `<body>` 手动加上这个 `id/class` 即可。

### js 污染的问题

暂时没有很好的办法解决，但是可以靠编码规范来约束：页面销毁之前清除自己页面上的定时器/全局事件，必要的时候，全局变量也应该销毁。

### 系统之间如何通信

系统之间通信一般有两种方式：自定义事件和本地存储。如果是两个系统相互跳转，可以用 URL 传数据。

通用数据还可以挂在在 window 上，如果挂在在 window 上有个问题是如何防止在控制台打开的情况下防止重要数据暴露，有两种方法：

- 监控 window 的 innerHeight outerHeight 差值，如果过大说明此时可能打开控制台
- 重写对象的 toString 方法，然后使用 `console.log('%s', obj)` 调用，console 函数语句只有在控制台打开时才会执行，此时由于类型转换的关系会调用 obj 的 toString 方法，可以该方法里改变全局变量，知道是否打开控制台。

### 子系统如何实现keep-alive

查看 single-spa-vue 源码可以发现，在 unmount 生命周期，它将 vue 实例 destroy（销毁了）并且清空了 DOM。所以实现 keep-alive 的关键在于子系统的 unmount 周期中不销毁 vue 实例并且不清空 DOM，采用 display:none 来隐藏子系统。而在 mount 周期，先判断子系统是否存在，如果存在，则去掉其 display:none 即可。

## qiankun 框架

qiankun 是蚂蚁金服开源的基于 single-spa 的一个前端微服务框架

### js沙箱（sandbox）是如何实现的

我们知道所有的全局的方法（alert，setTimeout，isNaN 等）、全局的变/常量（NaN，Infinity，var 声明的全局变量等）和全局对象（Array，String，Date 等）都属于 window 对象，而能导致 js 污染的也就是这些全局的方法和对象。

所以 qiankun 解决 js 污染的办法是：在子系统加载之前对 window 对象做一个快照（拷贝），然后在子系统卸载的时候恢复这个快照，即可以保证每次子系统运行的时候都是一个全新的 window 对象环境。

那么如何监测 window 对象的变化呢，直接将 window 对象进行一下深拷贝，然后深度对比各个属性显然可行性不高，qiankun 框架采用的是 ES6 新特性，proxy 代理方法。大致原理就是记录 window 对象在子系统运行期间新增、修改和删除的属性和方法，然后会在子系统卸载的时候复原这些操作。

重写事件绑定/解绑和定时器相关函数。addEventListener、removeEventListener、setInterval。不清除 setTimeout，毕竟使用了一次之后就没用了，影响不大

### 如何消除全局函数的影响

function 关键字直接声明一个全局函数，这个函数属于 window 对象，但是无法被 delete

声明全局函数有两种办法，一种是 function 关键字在全局环境下声明，另一种是以变量的形式添加：window.a = () => {}。我们知道 function 声明的全局函数是无法删除的，而变量的形式是可以删除的，qiankun 直接避免了function 关键字声明的全局函数。

### css 污染的问题

在子系统卸载的时候，将子系统引入css使用的 `<link>`、`<style>` 标签移除掉。移除的办法是重写 `<head>` 标签的 appendChild 方法，办法类似定时器的重写。

子系统加载时，会将所需要的 js/css 文件插入到 `<head>` 标签，而重写的 appendChild 方法会记录所插入的标签，然后子系统卸载的时候，会移除这些标签。

