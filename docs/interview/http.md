# HTTP 相关

HTTP 是一种超文本传输协议，构建于 TCP/IP 协议之上，是一个应用层协议

## HTTP 协议的主要特点

HTTP 具有 灵活可扩展、无连接、无状态、可靠传输、明文传输的特点。

- 灵活可扩展：1. 语义上的自由，只规定了基本格式（如：空格分隔单词、换行分隔字段），其他部分没有严格的语法限制；2. 传输格式的多样性（文本、图片等任意格式）
- 无连接：每完成一个请求就断开连接，HTTP 1.1 开始默认开启 keep-alive 长连接
- 无状态：单从 HTTP 协议上没有办法识别两次连接者身份，所以后来加入 cookie
- 可靠传输：HTTP 基于 TCP 协议，TCP 协议拥有可靠传输的特性
- 明文传输：协议里的报文直接使用文本形式传输，HTTP 2 后改为二进制传输

## HTTP 报文

### 请求报文

```md
<method> <request-url> <version>
<headers>

<entity-body>
```

### 响应报文

```md
<version> <state-code> <state-desc>
<headers>

<entity-body>
```

## GET 与 POST 区别

实际上没什么本质不同

- 语义不同，GET 获取数据，POST 修改数据
- GET 回退没有影响，POST 会再次发送数据
- GET 会被浏览器缓存下来，留下历史记录，POST 不会
- GET 是幂等的，POST 不是（幂等表示执行相同的操作，结果也是相同的）

## HTTP 1

http 1 默认使用的是短连接，并且缓存相关的头部字段只有 Expires 和 Last-Modified

http 1.1 默认开启 keep-alive 长连接，并且添加了 Cache-Control 和 Etag 这两个缓存相关的头部字段。

## HTTP 2

http 2 与 http 1 最大的变化是，在应用层和传输层之间加了「二进制分帧层」，原本的明文信息会在这一层转为二进制格式的数据，并且被分割为更小的单位「帧」进行传输，基于此，http 2 真正实现了多路复用，可以在同一时间使用一个 TCP 连接发送多个 http 请求，在 http 的层面解决了队头阻塞的问题。其他的不同点：头部压缩（在服务端和客户端之间建立哈希表，通过索引的方式压缩头部）、服务端推送。

HTTP 2 主要有如下改变：

- 头部压缩：在服务端和客户端之间建立哈希表，通过索引的方式压缩头部。
- 二进制分帧传输：HTTP 2 不再使用明文传输数据，而是将报文转为二进制格式传输，应用层(HTTP 2)和传输层(TCP)之间增加一个二进制分帧层，在二进制分帧层中 HTTP 2 会将所有传输的信息分割为更小的单位帧，并对它们采用二进制格式的编码。
- 多路复用：HTTP 2 允许同时通过单一的连接发起多重的请求-响应消息，由于 HTTP 2 加入了二进制分帧层，在每一帧中都有一个流标识，所以不同的 HTTP 请求的帧不分先后顺序，也就不需要排队等待。
- 服务端推送：服务器可以对客户端的一个请求发送多个响应。

HTTP 2 存在的最大的问题是：由于底层还是使用的 TCP 协议，所以在连接中出现丢包的情况下，需要等待重传，这会导致后面的所有数据被阻塞，这时对于 HTTP 1 来说，由于开启多个 TCP 连接，剩余的 TCP 连接还可以正常传输数据。所以未来的 HTTP 3 Google 才考虑使用 QUIC 协议替换 TCP 协议，QUIC 协议是基于 UDP。

## HTTP 3

http 3 不再基于 TCP 协议，而是改为 QUIC 协议，QUIC 基于 UDP 。

## HTTPS

HTTPS 协议是由 SSL + HTTP 协议构建的可进行加密传输，身份认证的网络协议。其原理是在 HTTP 和 TCP 之间建立了一个中间层，这个中间层的核心就是对数据加解密。TLS 是更新，更安全的 SSL 版本，TLS 中使用了两种加密技术：对称加密，非对称加密。

### HTTPS 加解密过程

https 其实就是在 HTTP 和 TCP 之间加一个对数据进行加解密的中间层。

它们的加密过程首先是非对称加密，

客户端发送 random 1 和加密方法列表；

服务端发送 random 2 、数字证书和加密方法；

客户端确认数字证书有效，然后发送使用证书中的公钥加密后的 random 3；

服务端使用私钥获取 random 3；

客户端服务端使用这三个随机数和相同的加密方法生成最终的密钥

后续就可以使用对称加密。

## 浏览器缓存

### 强缓存

Expires：过期时间

Cache-Control：max-age=3600

当 Expires 和 Cache-Control 同时存在的时候，Cache-Control 会优先考虑

Cache-Control 的 no-cache 代表使用协商缓存、no-store 才代表不使用缓存。

### 协商缓存

Last-modified / If-modified-Since：即最后修改时间，在浏览器第一次给服务器发送请求后，服务器会在响应头中加上这个字段，浏览器接收到后，如果再次请求，会在请求头中携带 If-Modified-Since 字段

Etag / If-None-Match：服务器根据当前文件的内容，给文件生成的唯一标识

当 Last-modified 和 Etag 同时存在的时候，ETag 会优先考虑。

## HTTP 常见状态码

- 1xx：指示信息，表示请求以接受，继续处理
- 2xx：成功状态码
- 301：永久重定向
- 302：临时重定向
- 304：命中协商缓存
- 4xx：客户端错误，请求有语法错误或请求无法实现
- 5xx：服务器错误，服务器未能实现合法的请求

## HTTP 的队头阻塞是什么

在 HTTP 2 之前，当 HTTP 开启长连接时，共用一个 TCP 连接，由于 HTTP 基于 请求-响应 模型，前一个请求没有响应，后一个请求就不会开始，如果当前请求耗时过长，其他的请求就会处于阻塞状态。（这里说的是 HTTP 协议本身的队头阻塞问题，实际上 TCP 协议也存在队头阻塞问题，两者并不相同，TCP 协议队头阻塞问题在于数据包，如果有编号 1、2、3 三个数据包，即使收到了 1、3，但是因为没有 2，3 号数据包依然会等待 2 号数据包到达之后才处理）。
HTTP 2 后，加入二进制分帧传输，每个请求被拆成最小单位帧在 stream 中传输，实现真正的多路复用，但是 TCP 的队头阻塞还是没有解决，为此 HTTP 3 中将以 QUIC 代替 TCP。

## HTTP 如何判断数据传输完成

1. 判断传输数据是否达到了 Content-Length，发送端在传输的时候会带上 Content-Length，来指明包体的长度。
2. 动态生成的文件没有 Content-Length，这时候会有 Transfer-Encoding: chunked 代替，chunked 编码的数据在最后有一个空 chunked 块，表明本次传输数据结束。

## TCP 三次握手、四次挥手

### 三次握手流程

- 客户端：标志位 SYN；seq（序列号）=x
- 服务端：标志位 SYN、ACK；seq=y、ack（确认序号）=x+1
- 客户端：标志位 ACK；ack=y+1

#### 为什么需要三次握手

根本原因是因为发送方和接收方建立连接前需要确认双发的初始序列号，但是双方没有一个全局统一的时钟，只有发送方才知道自己发出的序列号是不是过期的，所以最后必须由发送方确认，三次是满足这个条件的最少次数。

如果通信双方的通信次数只有两次，那么发送方一旦发出建立连接的请求之后它就没有办法撤回这一次请求，如果在网络状况复杂或者较差的网络中，发送方连续发送多次建立连接的请求，如果 TCP 建立连接只能通信两次，那么接收方只能选择接受或者拒绝发送方发起的请求，它并不清楚这一次请求是不是由于网络拥堵而早早过期的连接。

### 四次挥手流程

客户端：标志位 FIN；seq=x

服务端：标志位 ACK；ack=x+1

服务端：标志位 FIN；seq=y

客户端：标志位 ACK；ack=y+1

#### 为什么需要四次握手

因为一方发送 FIN 表示自己这方的数据全部发送完成后，另一方可能还有数据没有发送完，FIN 和 ACK 必须分开。

## TCP UDP QUIC

### TCP

[TCP](https://github.com/theydy/notebook/issues/13)

- TCP 是面向连接的，开始传输数据前需要先建立连接
- TCP 连接只能是一对一
- TCP 提供可靠的交付服务
- TCP 使用滑动窗口机制来实现流量控制，通过动态改变窗口的大小进行拥塞控制

#### TCP 的滑动窗口机制

滑动窗口分为 **发送窗口** 和 **接收窗口**，

发送窗口：保存着「已发送但未确认」和「未发送但允许发送」的数据，发送窗口的大小是动态变化的，等于接收窗口和拥塞窗口取小值。

接收窗口：接收窗口的大小等于接收方准备接收的数据大小，接收窗口的大小会通过报文告诉发送方。

#### TCP 的重传机制

超时重传：超过指定的时间没有响应，就会重传。

快速重传：接收到三次重复确认时，立即重传。

### UDP

- UDP 无连接
- UDP 不保证数据可靠性
- UDP 支持多播和广播

### QUIC

HTTP 3 基于 QUIC 实现，QUIC 通过 UDP 修改而成
